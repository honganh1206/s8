# Parsing Expressions

- Parsing expressions contains a few more challenges. One of them is the operator precedence: Supposed we want to parse the expression `5 * 5 + 10`, then the AST should represent the expression like `((5 * 5) + 10)`.

- The parser should know about the **operator precedences** of other cases like the "precedence bump" of `5 * (5 + 10)`

- The validity of a token's position depends on the **context**: The tokens that come before and after, and their precedence.
  - In expressions, *tokens of the same type can appear in multiple positions*. An example would be `-5 - 10` where the token `-` works as both the prefix operator and infix operator!
  - The parentheses also work as operators: In expressions like `5 * (add(2, 3) + 10)`, the outer pair of parentheses denotes a *grouped expression*, while the inner pair is a *call expression*.

- The **drill** for parsing different type of statements: We *build our AST node of that statement type* then we try to *fill its field by calling the parsing functions*.

## Expressions in S8

- Everything besides `let` and `return` statements is an expression. Consider some of them here:
  - Prefix operator `!true`
  - Infix operator `5 + 5`
  - Comparison operator `foo > bar`.
  - Identifiers as expressions `add(foo, bar)`
  - Function literals as first-class `let add = fn(x, y) { return x + y; }`
  - In-line If expression (not many have this) `let result = if (10 > 5) { true } else { false }`

## Brushing up some terminologies

- Expression: A question that always has an answer. Always produce a value
- Statement: A command or complete sentence. It does things.

```javascript
// Expressions (they produce values):
5 + 3        // produces 8
"hi" + "!"   // produces "hi!"
getName()    // produces whatever name it finds

// Statements (they do things):
let age = 5;         // declares a variable
if (hungry) {...}    // makes a decision
return cake;         // gives something back
```

- Prefix operator: An operator *in front of* its operand like `--5`
- Postfix operator: An operator *after* its operand like `foobar++`
- Infix opeartor: An operator that *sits between* its operands like `5 * 8`
- Binary expressions: Where the operator has two operands
- Operator precedence/Order of operations: The priority different operators have like `5 + 5 * 10`

## Preparing the Expression Statement

- This might sound weird: We need to add *expression statements* - a statement consists solely of **one expression** like a wrapper.

```
let x = 5;
x + 10; // Legal expression statement
```

- This feature exists mostly in scripting languages to *have one line consisting only of an expression*

- Tip: We add the `String()` method to our `Node` interface for debugging purposes!

[[Pratt Parsing]]

## More on identifiers

- *Identifiers are expressions too*, so they can be used in all contexts such as `foo + bar`

- We add an *optional* check for semicolon when parsing expression statements - so we can do things like `5 + 5` in our REPL just like JS!


- We will have `prefixParseFn` function type to handle cases when we *encounter the associated token type in prefix position*, and `infixParseFn` to handle *token type in infix position case*

- The parsing functions of both types `prefixParsingFn` and `infixParsingFn` will follow this **same protocol**: We return the AST node with the current token and the literal value of the token **without** advancing the token. This is an important principle in [[Recursive-descent Parsing]]


## More on Integer Literals

- *Integer literals are expressions*. The value they produce is the integer itself for example `5;`

```
// Places where integer literals can occur
let x = 5;
add(5, 10);
5 + 5 + 5;
```

- Note that the literal value of the AST node before parsing will be of `string` type and we need to convert that to `int` type when constructing our node.
