# Extending the Parser

[[Boolean Literals]]

[[Grouped Expressions]]

## If Expressions

- For this we will have to deal with *different token and expression types*

- The If Expressions are similar to the Ifs in other languages. Note that the `else` is optional
```js
if (x > y) {
  return x;
} else {
  return y;
}

// Or just this
if (x > y) {
  return x;
}
```
- Note that in s8 **if-else-conditionals are expressions**, so we do not need the return statement here
```js
let foobar = if (x > y) { x } else { y };
```
- Structure of our if-else conditionals: `if (<condition>) <consequence> else <alternative>`

- Our `<consequence>` and `<alternative>` will be of type `BlockStatement` as they are a *series of statements*

## Function Literals

This is our function literals--They will be of type **Expression**:
```js
funk(x, y) {
  return x + y;
}

let myFunction = funk(x, y) { return x + y; }
```
Structure: `funk <parameters> <block statement>` and parameters are just *a list of identifiers* like this `(<parameter one>, <parameter two>, ...)`

Note that *the parameter list could be empty*
```js
funk() {
  return foobar + barfoo;
}
```
A function literal could work as *an expression in a return statement*, and this return statement is inside another function literal
```js
funk() {
  return funk(x, y) { return x > y; };
}
```
We can even use a function literal as **an argument** for another function literal
```js
myFunc(x, y, funk(x, y) { return x > y; });
```

