# Parsing Let statements

- What is parsing let statements correctly? => Our parser must produce an AST that *accurately represent the information contained in the original let statement*
 - Our programming language will have this following form of variable binding with `let` statement: `let <identifier> = <expression>;`
- An expression produces a value, a statement does not. However, what exactly an expression or a statement is or which one produces the value *depends on the language*. A function literal could be an expression in some languages while in others it is not (it will be in s8 though!)

```js
// An example of a function literal
 const add = function(a, b) {
    return a + b;
};
```
- Example: A node for a variable binding in the form of `let x = 5;`
  - Fields to have? One for the token itself `let`, one for the identifier `x`, one pointing to the **expression** on the right side of the variable (not the literal value `5`) => 3 in total
  - Tracking? The node also needs to keep track of the token it is associated with so we can implement the `TokenLiteral()` method. => A field named `Token` of type `Token`
- As to why the identifier in the `let` statement does not produce a value but it still implements the `Expression` interface? *To keep things simple*: Some identifiers **DO** produce value like `let x = valueProducingIdentifier`.
- Using the `Identifier` structfor both variable names and as a general expression is a good practice: Sometimes we use something like `myVar + 5` as a standalone expression/variable reference, and if so we have to do this:

 ```go
// For variable declarations
type VariableName struct {
    Token token.Token
    Value string
}

// For variable references
type VariableReference struct {
    Token token.Token
    Value string
}
```

- When creating a parser, we need to both set the current token + next token for cases like `5;`, in which the current token is `token.INT` and the next token indicates whether we are dealing with EOF or starting an arithmetic expression.

- [[Recursive-descent Parsing]]
