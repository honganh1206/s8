# Parsing Let statements

## What our parser will do

- What is parsing let statements correctly? => Our parser must produce an AST that *accurately represent the information contained in the original let statement*

- What will our parser do? It **repeatedly** advances the tokens + checks the current token to decide whether to *call another parsing function* or *throw an error*.

- The flow of the `parseProgram()` function - the key function of our parser:

```
 parseProgram()
|
|---> program = newProgramASTNode()
|
|---> advanceTokens()
|
|---> Loop: currentToken() != EOF_TOKEN
|       |
|       +--> IF currentToken() == LET_TOKEN
|       |       |
|       |       +--> statement = parseLetStatement()
|       |
|       +--> ELSE IF currentToken() == RETURN_TOKEN
|       |       |
|       |       +--> statement = parseReturnStatement()
|       |
|       +--> ELSE IF currentToken() == IF_TOKEN
|               |
|               +--> statement = parseIfStatement()
|
|---> IF statement != null
|       |
|       +--> program.Statements.push(statement)
|
|---> advanceTokens()
|
+---> return program
```

- The basic idea behind `parseProgram()`: We first build the root node of the AST -> Build the child nodes + statements by *calling functions that know which AST node to construct* based on the current token.

- When creating a parser, we need to both set the current token + next token for cases like `5;`, in which the current token is `token.INT` and the next token indicates whether we are dealing with EOF or starting an arithmetic expression.

## Variable binding in s8
 - Our programming language will have this following form of variable binding with `let` statement: `let <identifier> = <expression>;`

- An expression produces a value, a statement does not. However, what exactly an expression or a statement is or which one produces the value *depends on the language*. A function literal could be an expression in some languages while in others it is not (it will be in s8 though!)

```js
// An example of a function literal
 const add = function(a, b) {
    return a + b;
};
```
- Example: A node for a variable binding in the form of `let x = 5;`
  - Fields to have? One for the token itself `let`, one for the identifier `x`, one pointing to the **expression** on the right side of the variable (not the literal value `5`) => 3 in total
  - Tracking? The node also needs to keep track of the token it is associated with so we can implement the `TokenLiteral()` method. => A field named `Token` of type `Token`

- As to why the identifier in the `let` statement does not produce a value but it still implements the `Expression` interface? *To keep things simple*: Some identifiers **DO** produce value like `let x = valueProducingIdentifier`.

- Using the `Identifier` structfor both variable names and as a general expression is a good practice: Sometimes we use something like `myVar + 5` as a standalone expression/variable reference, and if so we have to do this:

 ```go
// For variable declarations
type VariableName struct {
    Token token.Token
    Value string
}

// For variable references
type VariableReference struct {
    Token token.Token
    Value string
}
```

- [[Recursive-descent Parsing]]

## Recursive `parseExpression()`

- Note that our `parseExpression()` function and those alike are quite **recursive**

```
 parseExpression()
|
|---> IF currentToken() == INTEGER_TOKEN
|       |
|       +--> IF nextToken() == PLUS_TOKEN
|       |       |
|       |       +--> return parseOperatorExpression()
|       |
|       +--> ELSE IF nextToken() == SEMICOLON_TOKEN
|               |
|               +--> return parseIntegerLiteral()
|
|---> ELSE IF currentToken() == LEFT_PAREN
|       |
|       +--> return parseGroupedExpression()
|
|---> [Additional conditions if any, represented as ...]
|
+---> return

---


parseOperatorExpression()
|
|---> operatorExpression = newOperatorExpression()
|       |
|       +--> operatorExpression.left = parseIntegerLiteral()
|       |
|       +--> advanceTokens()
|       |       |
|       |       +--> operatorExpression.operator = currentToken()
|       |
|       +--> advanceTokens()
|               |
|               +--> operatorExpression.right = parseExpression() // Recursion
|
+---> return operatorExpression
```

- When parsing an expression like `5 + 5`, we first parse `5 +` and then call the `parseExpression()` recursively because *there might be another operator expression* like `5 + 5 * 10`.
