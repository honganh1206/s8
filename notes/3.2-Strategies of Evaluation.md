# Strategies of Evaluation

The ways we evaluate our code differ with different interpreter implementations

> [!IMPORTANT]
> The line between interpreters and compilers is a **blurry** one

While it is believed that an interpreter does not leave executable artifacts behind (in contrast to the compiler, which does just that), _real-world and highly optimized programming languages prove this to be gray_ -- the two notions get fuzzy real fast

The classical approach: We traverse the AST by visiting each node -> Do what the nodes denote -- All on the fly. This is called **tree-walking interpreters**--the archetype of interpreters

> [!NOTE]
> Sometimes the evaluation step is preceded by small optimizations that _rewrite the AST_ e.g., remove unused variable bindings, convert AST into another intermediate representation (IR)

Another approach: Some programming languages **convert the AST into [Bytecode](./Bytecode.md) then interpret it**
